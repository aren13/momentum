---
description: Create an execution plan for a phase
args:
  - name: phase
    description: Phase number to plan (e.g., 1, 2, 3)
    required: false
allowed_tools:
  - Read
  - Write
  - Bash
  - AskUserQuestion
  - Glob
  - Grep
---

# Create Execution Plan

Create a detailed, executable plan for a specific phase.

## Arguments

- `$ARGUMENTS` - Phase number (optional, auto-detects next phase if not provided)

## Pre-flight Checks

1. Verify `.momentum/ROADMAP.md` exists
2. Validate phase number exists in roadmap
3. Check for existing plans in phase directory

## Process

### Step 1: Determine Phase

If phase number provided:
- Use that phase
- Validate it exists in ROADMAP.md

If no phase number:
- Find the first phase that doesn't have a completed plan
- Confirm with user

### Step 2: Load Context

Read these files to understand full context:

1. `.momentum/PROJECT.md` - Project goals and scope
2. `.momentum/ROADMAP.md` - Phase description and deliverables
3. `.momentum/STATE.md` - Current decisions and context
4. `.momentum/phases/XX-name/CONTEXT.md` - Phase-specific context (if exists)
5. `.momentum/phases/XX-name/RESEARCH.md` - Research findings (if exists)
6. Previous phase summaries - What's been done

### Step 3: Check for Existing Plans

```bash
ls .momentum/phases/[phase-dir]/*-PLAN.md 2>/dev/null
```

Calculate next plan number: existing plans + 1

### Step 4: Plan Interview

Ask the user:

1. "What specific objective should this plan achieve?"
2. "What are the concrete tasks needed?" (Open editor for detailed input)
3. "How will we verify success?"
4. "Any dependencies on external resources or decisions?"
5. "Do you want checkpoints for verification pauses?" (For complex plans)

### Step 5: Analyze Tasks

For each task, determine:
- Files that will be modified/created
- Dependencies on other tasks
- Verification criteria
- Estimated complexity

### Step 6: Generate PLAN.md

Create `.momentum/phases/XX-name/XX-YY-PLAN.md`:

```markdown
# Execution Plan: [Objective]

> Phase [X], Plan [Y]

## Objective

[Clear objective statement]

## Context

### Project Reference
*See .momentum/PROJECT.md*

### Phase Context
[Relevant phase information]

### Prerequisites
- [What must be true before starting]

### Dependencies
- Previous plans: [list or "None"]
- External: [any external dependencies]

## Tasks

### Task 1: [Name]

**Description:** [What to do]

**Files:**
- [file1.js] - [what to do]
- [file2.js] - [what to do]

**Steps:**
1. [Step 1]
2. [Step 2]

**Verification:**
- [ ] [How to verify this task]

---

### Task 2: [Name]

[Same structure]

---

[Continue for all tasks]

## Verification Steps

1. [ ] All tasks completed
2. [ ] No regressions introduced
3. [ ] Code follows conventions
4. [ ] [Custom verification]

## Success Criteria

[What "done" looks like]

## Execution Strategy

**Mode:** [Sequential/Parallel/Hybrid]
**Estimated Tasks:** [N]
**Checkpoints:** [Yes/No]

---

## Execution Log

*Updated during execution*

---

*Generated by Momentum*
```

### Step 7: Commit

```bash
git add .momentum/phases/
git commit -m "chore: create plan XX-YY for phase X"
```

### Step 8: Output

```
âœ“ Plan created: XX-YY-PLAN.md

Objective: [objective]
Tasks: [N]
Strategy: [strategy]

Next: Run /mtm:execute [path] to execute this plan
   or Run /mtm:plan [X] to create another plan for this phase
```

## Task Definition Best Practices

Each task should:
- Be atomic and independently verifiable
- Specify exact files to modify
- Include clear verification criteria
- Have no ambiguity

Example good task:
```markdown
### Task 3: Add user authentication endpoint

**Description:** Create POST /api/auth/login endpoint with JWT token generation

**Files:**
- src/routes/auth.js - Create new file with login route
- src/middleware/auth.js - Add JWT verification middleware
- src/config/jwt.js - Add JWT configuration

**Steps:**
1. Create auth route file with login handler
2. Implement password verification using bcrypt
3. Generate JWT token on successful login
4. Add auth middleware for protected routes

**Verification:**
- [ ] POST /api/auth/login returns JWT for valid credentials
- [ ] Invalid credentials return 401
- [ ] Token contains user ID and expiry
```

## Parallel Execution Detection

Analyze tasks for parallel execution potential:
- Tasks with no shared files can run in parallel
- Tasks with dependencies must run sequentially
- Mark parallel-safe tasks in the plan
