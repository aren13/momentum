# Phase 1, Plan 1: Git Worktree Engine - Core Implementation

## Objective

Implement the `WorktreeManager` class to enable isolated workspace development using git worktrees. This is the foundation for zero-risk development where the main branch is never touched during active work.

## Context

**Why Worktrees?**
- Git worktrees allow multiple working directories from a single repository
- Each worktree has its own HEAD, index, and working tree
- Changes in one worktree don't affect others
- Perfect for parallel agent work

**Reference:** `git worktree --help`

## Tasks

### Task 1: Create WorktreeManager Class

**Type:** create
**Files:** `momentum/lib/core/worktree.js`
**Action:** Create the core worktree management class

```javascript
/**
 * WorktreeManager - Git worktree isolation for zero-risk development
 */
import { existsSync, mkdirSync, rmSync, readdirSync } from 'fs';
import { join } from 'path';
import { execSync, exec } from 'child_process';

export class WorktreeManager {
  constructor(repoDir = process.cwd()) {
    this.repoDir = repoDir;
    this.worktreesDir = join(repoDir, '.worktrees');
  }

  /**
   * Initialize worktrees directory
   */
  init() {
    if (!existsSync(this.worktreesDir)) {
      mkdirSync(this.worktreesDir, { recursive: true });
    }
    // Add to gitignore
    this.ensureGitignore();
  }

  /**
   * Create a new worktree for a task
   */
  async create(name, baseBranch = 'main') {
    const worktreePath = join(this.worktreesDir, name);
    const branchName = `worktree/${name}`;

    if (existsSync(worktreePath)) {
      throw new Error(`Worktree already exists: ${name}`);
    }

    // Create worktree with new branch
    execSync(
      `git worktree add -b "${branchName}" "${worktreePath}" "${baseBranch}"`,
      { cwd: this.repoDir, stdio: 'pipe' }
    );

    return {
      name,
      path: worktreePath,
      branch: branchName,
      baseBranch
    };
  }

  /**
   * List all active worktrees
   */
  list() {
    const output = execSync('git worktree list --porcelain', {
      cwd: this.repoDir,
      encoding: 'utf8'
    });

    return this.parseWorktreeList(output);
  }

  /**
   * Delete a worktree
   */
  async delete(name, force = false) {
    const worktreePath = join(this.worktreesDir, name);
    const branchName = `worktree/${name}`;

    if (!existsSync(worktreePath)) {
      throw new Error(`Worktree not found: ${name}`);
    }

    // Remove worktree
    execSync(
      `git worktree remove ${force ? '--force' : ''} "${worktreePath}"`,
      { cwd: this.repoDir, stdio: 'pipe' }
    );

    // Delete branch
    try {
      execSync(`git branch -D "${branchName}"`, {
        cwd: this.repoDir,
        stdio: 'pipe'
      });
    } catch {
      // Branch may already be deleted
    }

    return true;
  }

  /**
   * Merge worktree back to target branch
   */
  async merge(name, target = 'main') {
    const worktreePath = join(this.worktreesDir, name);
    const branchName = `worktree/${name}`;

    // Check for uncommitted changes
    const status = execSync('git status --porcelain', {
      cwd: worktreePath,
      encoding: 'utf8'
    });

    if (status.trim()) {
      throw new Error(`Worktree has uncommitted changes: ${name}`);
    }

    // Switch to target and merge
    execSync(`git checkout ${target}`, { cwd: this.repoDir, stdio: 'pipe' });

    try {
      execSync(`git merge --no-ff "${branchName}" -m "Merge ${name}"`, {
        cwd: this.repoDir,
        stdio: 'pipe'
      });
      return { success: true, conflicts: false };
    } catch (err) {
      return { success: false, conflicts: true, error: err.message };
    }
  }

  /**
   * Clean up completed worktrees
   */
  async clean() {
    const worktrees = this.list();
    const cleaned = [];

    for (const wt of worktrees) {
      if (wt.path.includes('.worktrees') && wt.merged) {
        await this.delete(wt.name);
        cleaned.push(wt.name);
      }
    }

    // Prune stale worktrees
    execSync('git worktree prune', { cwd: this.repoDir, stdio: 'pipe' });

    return cleaned;
  }

  /**
   * Get worktree info
   */
  get(name) {
    const worktreePath = join(this.worktreesDir, name);

    if (!existsSync(worktreePath)) {
      return null;
    }

    const branch = execSync('git branch --show-current', {
      cwd: worktreePath,
      encoding: 'utf8'
    }).trim();

    const status = execSync('git status --porcelain', {
      cwd: worktreePath,
      encoding: 'utf8'
    });

    return {
      name,
      path: worktreePath,
      branch,
      clean: !status.trim(),
      status: status.trim().split('\n').filter(Boolean)
    };
  }

  /**
   * Parse git worktree list output
   */
  parseWorktreeList(output) {
    const worktrees = [];
    const entries = output.trim().split('\n\n');

    for (const entry of entries) {
      const lines = entry.split('\n');
      const wt = {};

      for (const line of lines) {
        if (line.startsWith('worktree ')) {
          wt.path = line.replace('worktree ', '');
          wt.name = wt.path.split('/').pop();
        } else if (line.startsWith('HEAD ')) {
          wt.head = line.replace('HEAD ', '');
        } else if (line.startsWith('branch ')) {
          wt.branch = line.replace('branch refs/heads/', '');
        }
      }

      if (wt.path) {
        worktrees.push(wt);
      }
    }

    return worktrees;
  }

  /**
   * Ensure .worktrees is in gitignore
   */
  ensureGitignore() {
    const gitignorePath = join(this.repoDir, '.gitignore');
    const ignoreEntry = '.worktrees/';

    if (existsSync(gitignorePath)) {
      const content = require('fs').readFileSync(gitignorePath, 'utf8');
      if (!content.includes(ignoreEntry)) {
        require('fs').appendFileSync(gitignorePath, `\n${ignoreEntry}\n`);
      }
    }
  }
}

export default WorktreeManager;
```

**Verify:**
- [ ] Class exports correctly
- [ ] All methods defined

**Done:** [ ]

---

### Task 2: Add Worktree CLI Commands

**Type:** create
**Files:** `momentum/commands/worktree.md`
**Action:** Create slash command for worktree management

```yaml
---
description: Manage git worktrees for isolated development
arguments:
  - name: action
    description: "Action: create, list, delete, merge, clean"
    required: true
  - name: name
    description: "Worktree name (for create/delete/merge)"
    required: false
---
```

```markdown
# Worktree Management

Execute the requested worktree action:

## Actions

### create <name>
Create a new isolated worktree for development.

### list
Show all active worktrees.

### delete <name>
Remove a worktree and its branch.

### merge <name>
Merge worktree back to main branch.

### clean
Remove completed/stale worktrees.

## Context
@momentum/lib/core/worktree.js

Invoke the appropriate WorktreeManager method based on the action.
```

**Verify:**
- [ ] Command file created
- [ ] All actions documented

**Done:** [ ]

---

### Task 3: Integrate with Executor

**Type:** modify
**Files:** `momentum/lib/core/executor.js`
**Action:** Modify executor to optionally use worktrees

Add worktree support:
```javascript
// In execute() method, add option check:
if (config.features?.useWorktrees) {
  const { WorktreeManager } = await import('./worktree.js');
  const wm = new WorktreeManager(this.dir);
  const planName = basename(resolvedPath).replace('-PLAN.md', '');
  const wt = await wm.create(planName);
  // Execute in worktree context
  this.executionContext = wt.path;
}
```

**Verify:**
- [ ] Worktree created when enabled
- [ ] Execution happens in worktree
- [ ] Config option respected

**Done:** [ ]

---

### Task 4: Add Configuration Option

**Type:** modify
**Files:** `momentum/lib/core/project.js`
**Action:** Add worktree feature flag to default config

In `writeProjectFiles()`, update config:
```javascript
features: {
  parallelExecution: true,
  autoCheckpoints: true,
  learningMode: true,
  smartRetries: true,
  useWorktrees: true,      // NEW
  autoCleanWorktrees: true // NEW
}
```

**Verify:**
- [ ] Config includes new options
- [ ] Defaults to enabled

**Done:** [ ]

---

## Verification Steps

1. [ ] `npm test` passes (if tests exist)
2. [ ] `node bin/cli.js worktree list` works
3. [ ] Create worktree: `node bin/cli.js worktree create test-task`
4. [ ] Verify worktree exists in `.worktrees/test-task`
5. [ ] Delete worktree: `node bin/cli.js worktree delete test-task`
6. [ ] No regressions in existing functionality

## Success Criteria

- WorktreeManager class fully functional
- CLI commands operational
- Executor can optionally use worktrees
- Main branch protection verified

## Output

Upon completion, create `01-01-SUMMARY.md` documenting:
- Implementation details
- Any deviations from plan
- Test results
- Next steps for Plan 2 (executor integration)

---

*Generated by Momentum Planning*
