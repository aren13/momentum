# Phase 3, Plan 1: Self-Healing QA Loop - Implementation

## Objective

Implement the `QARunner` class that automatically verifies code changes, detects failures, and attempts self-healing fixes for up to N iterations.

## Context

**Why Self-Healing QA?**
- Auto-Claude's killer feature: catches issues before human review
- Up to 50 iterations of automatic fix attempts
- Reduces manual review burden by 80%+
- Ensures consistent quality standards

**Integration Points:**
- Runs after each agent completes in worktree
- Runs before merge back to main
- Can be triggered manually via CLI

## Tasks

### Task 1: Create QARunner Class

**Type:** create
**Files:** `momentum/lib/core/qa-runner.js`
**Action:** Create the self-healing QA runner

```javascript
/**
 * QARunner - Self-healing quality assurance loop
 */
import { execSync, exec } from 'child_process';
import { existsSync, readFileSync } from 'fs';
import { join } from 'path';

export class QARunner {
  constructor(options = {}) {
    this.maxIterations = options.maxIterations || 10;
    this.workDir = options.workDir || process.cwd();
    this.checks = options.checks || ['lint', 'typecheck', 'test'];
    this.fixEnabled = options.fixEnabled !== false;
    this.history = [];
  }

  /**
   * Run all QA checks
   */
  async run() {
    const results = {
      passed: true,
      checks: [],
      iterations: 0
    };

    for (const check of this.checks) {
      const result = await this.runCheck(check);
      results.checks.push(result);
      if (!result.passed) {
        results.passed = false;
      }
    }

    return results;
  }

  /**
   * Run a single check
   */
  async runCheck(checkType) {
    const result = {
      type: checkType,
      passed: false,
      output: '',
      fixable: false,
      fixCommand: null
    };

    try {
      switch (checkType) {
        case 'lint':
          result.output = this.runLint();
          result.passed = true;
          break;

        case 'typecheck':
          result.output = this.runTypecheck();
          result.passed = true;
          break;

        case 'test':
          result.output = this.runTests();
          result.passed = true;
          break;

        case 'build':
          result.output = this.runBuild();
          result.passed = true;
          break;

        default:
          result.output = `Unknown check type: ${checkType}`;
      }
    } catch (err) {
      result.passed = false;
      result.output = err.stdout || err.message;
      result.fixable = this.isFixable(checkType, result.output);
      result.fixCommand = this.getFixCommand(checkType);
    }

    return result;
  }

  /**
   * Run lint check
   */
  runLint() {
    // Detect linter
    if (existsSync(join(this.workDir, 'package.json'))) {
      const pkg = JSON.parse(readFileSync(join(this.workDir, 'package.json')));

      if (pkg.scripts?.lint) {
        return execSync('npm run lint', {
          cwd: this.workDir,
          encoding: 'utf8',
          stdio: 'pipe'
        });
      }

      // Try common linters
      if (pkg.devDependencies?.eslint || pkg.dependencies?.eslint) {
        return execSync('npx eslint . --ext .js,.ts,.jsx,.tsx', {
          cwd: this.workDir,
          encoding: 'utf8',
          stdio: 'pipe'
        });
      }
    }

    // Python
    if (existsSync(join(this.workDir, 'pyproject.toml'))) {
      return execSync('ruff check .', {
        cwd: this.workDir,
        encoding: 'utf8',
        stdio: 'pipe'
      });
    }

    return 'No linter configured';
  }

  /**
   * Run typecheck
   */
  runTypecheck() {
    if (existsSync(join(this.workDir, 'tsconfig.json'))) {
      return execSync('npx tsc --noEmit', {
        cwd: this.workDir,
        encoding: 'utf8',
        stdio: 'pipe'
      });
    }

    if (existsSync(join(this.workDir, 'pyproject.toml'))) {
      return execSync('mypy .', {
        cwd: this.workDir,
        encoding: 'utf8',
        stdio: 'pipe'
      });
    }

    return 'No type checker configured';
  }

  /**
   * Run tests
   */
  runTests() {
    if (existsSync(join(this.workDir, 'package.json'))) {
      const pkg = JSON.parse(readFileSync(join(this.workDir, 'package.json')));

      if (pkg.scripts?.test) {
        return execSync('npm test', {
          cwd: this.workDir,
          encoding: 'utf8',
          stdio: 'pipe'
        });
      }
    }

    if (existsSync(join(this.workDir, 'pytest.ini')) ||
        existsSync(join(this.workDir, 'pyproject.toml'))) {
      return execSync('pytest', {
        cwd: this.workDir,
        encoding: 'utf8',
        stdio: 'pipe'
      });
    }

    return 'No test runner configured';
  }

  /**
   * Run build
   */
  runBuild() {
    if (existsSync(join(this.workDir, 'package.json'))) {
      const pkg = JSON.parse(readFileSync(join(this.workDir, 'package.json')));

      if (pkg.scripts?.build) {
        return execSync('npm run build', {
          cwd: this.workDir,
          encoding: 'utf8',
          stdio: 'pipe'
        });
      }
    }

    return 'No build script configured';
  }

  /**
   * Check if error is auto-fixable
   */
  isFixable(checkType, output) {
    const fixablePatterns = {
      lint: [
        /potentially fixable with/i,
        /--fix/i,
        /auto-fixable/i
      ],
      typecheck: [], // Usually not auto-fixable
      test: []       // Usually not auto-fixable
    };

    const patterns = fixablePatterns[checkType] || [];
    return patterns.some(p => p.test(output));
  }

  /**
   * Get fix command for check type
   */
  getFixCommand(checkType) {
    const fixCommands = {
      lint: 'npm run lint -- --fix',
      format: 'npx prettier --write .'
    };

    return fixCommands[checkType] || null;
  }

  /**
   * Attempt to fix failures
   */
  async fix(failures) {
    const fixed = [];

    for (const failure of failures) {
      if (failure.fixable && failure.fixCommand) {
        try {
          execSync(failure.fixCommand, {
            cwd: this.workDir,
            encoding: 'utf8',
            stdio: 'pipe'
          });
          fixed.push(failure.type);
        } catch (err) {
          // Fix failed
        }
      }
    }

    return fixed;
  }

  /**
   * Run the self-healing loop
   */
  async loop() {
    let iteration = 0;

    while (iteration < this.maxIterations) {
      iteration++;

      // Run all checks
      const results = await this.run();
      this.history.push({ iteration, results });

      // All passed?
      if (results.passed) {
        return {
          success: true,
          iterations: iteration,
          history: this.history
        };
      }

      // Try to fix
      const failures = results.checks.filter(c => !c.passed);
      const fixableFailures = failures.filter(f => f.fixable);

      if (fixableFailures.length === 0) {
        // Nothing we can auto-fix
        return {
          success: false,
          iterations: iteration,
          unfixable: failures,
          history: this.history
        };
      }

      // Attempt fixes
      const fixed = await this.fix(fixableFailures);

      if (fixed.length === 0) {
        // No progress made
        return {
          success: false,
          iterations: iteration,
          unfixable: failures,
          history: this.history
        };
      }

      // Loop continues...
    }

    // Max iterations reached
    return {
      success: false,
      iterations: this.maxIterations,
      reason: 'max_iterations',
      history: this.history
    };
  }

  /**
   * Generate QA report
   */
  generateReport() {
    const lastRun = this.history[this.history.length - 1];

    return {
      summary: lastRun?.results.passed ? 'PASSED' : 'FAILED',
      totalIterations: this.history.length,
      checks: lastRun?.results.checks || [],
      timeline: this.history.map(h => ({
        iteration: h.iteration,
        passed: h.results.passed,
        failedChecks: h.results.checks.filter(c => !c.passed).map(c => c.type)
      }))
    };
  }
}

export default QARunner;
```

**Verify:**
- [ ] Class exports correctly
- [ ] Lint detection works
- [ ] Loop terminates correctly

**Done:** [ ]

---

### Task 2: Integrate with Agent Completion

**Type:** modify
**Files:** `momentum/lib/core/agent-pool.js`
**Action:** Run QA after agent completes

Add QA step in agent completion:

```javascript
// In spawn() method, after process.on('close'):
process.on('close', async (code) => {
  if (code === 0 && config.features?.autoQA) {
    const { QARunner } = await import('./qa-runner.js');
    const qa = new QARunner({
      workDir: worktree.path,
      maxIterations: config.features?.qaIterations || 10
    });

    const qaResult = await qa.loop();
    agent.qaResult = qaResult;

    if (!qaResult.success) {
      agent.status = 'qa_failed';
      this.emit('agent:qa_failed', { taskId, qaResult });
    }
  }
  // ... rest of completion handler
});
```

**Verify:**
- [ ] QA runs after agent completion
- [ ] QA failure blocks merge
- [ ] Events emit correctly

**Done:** [ ]

---

### Task 3: Add QA CLI Command

**Type:** create
**Files:** `momentum/commands/qa.md`
**Action:** Create slash command for QA

```markdown
---
description: Run quality assurance checks with self-healing
arguments:
  - name: path
    description: "Path to check (default: current directory)"
    required: false
  - name: iterations
    description: "Max fix iterations (default: 10)"
    required: false
---

# QA Runner

Run automated quality checks with self-healing fixes.

## Checks Performed
1. Lint (ESLint, Ruff, etc.)
2. Type checking (TypeScript, MyPy)
3. Tests (Jest, Pytest, etc.)
4. Build verification

## Self-Healing
For fixable issues (lint, formatting), attempts automatic fixes
up to the specified iteration limit.

## Context
@momentum/lib/core/qa-runner.js

Invoke QARunner and report results.
```

**Verify:**
- [ ] Command file created
- [ ] Options documented

**Done:** [ ]

---

### Task 4: Add QA Pre-Merge Gate

**Type:** modify
**Files:** `momentum/lib/core/worktree.js`
**Action:** Add QA check before merge

In `merge()` method:

```javascript
async merge(name, target = 'main', options = {}) {
  // Run QA before merge
  if (options.qaRequired !== false) {
    const { QARunner } = await import('./qa-runner.js');
    const worktreePath = join(this.worktreesDir, name);

    const qa = new QARunner({ workDir: worktreePath });
    const qaResult = await qa.run();

    if (!qaResult.passed) {
      throw new Error(`QA failed in worktree ${name}. Fix issues before merging.`);
    }
  }

  // ... rest of merge logic
}
```

**Verify:**
- [ ] QA runs before merge
- [ ] Failed QA blocks merge
- [ ] Option to skip QA

**Done:** [ ]

---

## Verification Steps

1. [ ] Create a file with lint errors
2. [ ] Run `momentum qa`
3. [ ] Verify auto-fix attempts
4. [ ] Verify iteration limit respected
5. [ ] Verify report generation
6. [ ] Test merge blocking

## Success Criteria

- QA catches common errors
- Auto-fix works for lint/format
- Clear reporting of unfixable issues
- Merge blocked until QA passes
- Configurable iteration limits

## Output

Create `03-01-SUMMARY.md` with:
- Implementation details
- Fix success rates
- Performance impact
- Recommendations for QA improvements

---

*Generated by Momentum Planning*
