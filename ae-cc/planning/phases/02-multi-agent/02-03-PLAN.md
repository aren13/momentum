# Phase 2, Plan 3: Task Dependency Resolution

## Objective

Implement the `DependencyResolver` class to parse task dependencies, build dependency graphs, and determine optimal execution order for task distribution.

## Context

**Why Dependency Resolution?**
- Tasks often depend on other tasks completing first
- Prevents race conditions and ordering issues
- Enables intelligent scheduling across agents
- Detects circular dependencies before execution

**Dependencies:**
- Phase 2, Plan 1 (AgentPool) must be complete
- Graph algorithms for topological sort

## Tasks

### Task 1: Create DependencyResolver Class

**Type:** create
**Files:** `momentum/lib/core/dependency-resolver.js`
**Action:** Create dependency analysis and resolution engine

```javascript
/**
 * DependencyResolver - Task dependency analysis and execution ordering
 */
export class DependencyResolver {
  constructor() {
    this.tasks = new Map();
    this.dependencies = new Map();
    this.graph = null;
  }

  /**
   * Add task with dependencies
   */
  addTask(task) {
    this.tasks.set(task.id, task);

    // Parse dependencies from task
    const deps = this.parseDependencies(task);
    this.dependencies.set(task.id, deps);

    return this;
  }

  /**
   * Add multiple tasks
   */
  addTasks(tasks) {
    tasks.forEach(task => this.addTask(task));
    return this;
  }

  /**
   * Parse dependencies from task metadata
   */
  parseDependencies(task) {
    const deps = [];

    // Check various dependency formats
    if (task.dependsOn) {
      // Array of task IDs
      if (Array.isArray(task.dependsOn)) {
        deps.push(...task.dependsOn);
      }
      // Single task ID
      else if (typeof task.dependsOn === 'string') {
        deps.push(task.dependsOn);
      }
    }

    // Check for dependencies in task description
    if (task.description) {
      // Pattern: "depends on: task-1, task-2"
      const match = task.description.match(/depends on:?\s*([^\n]+)/i);
      if (match) {
        const depIds = match[1].split(',').map(d => d.trim());
        deps.push(...depIds);
      }
    }

    // Check for dependencies in metadata
    if (task.metadata?.dependencies) {
      deps.push(...task.metadata.dependencies);
    }

    return [...new Set(deps)]; // Remove duplicates
  }

  /**
   * Build dependency graph
   */
  buildGraph() {
    const graph = {
      nodes: new Set(),
      edges: new Map(),
      inDegree: new Map()
    };

    // Add all tasks as nodes
    for (const taskId of this.tasks.keys()) {
      graph.nodes.add(taskId);
      graph.edges.set(taskId, new Set());
      graph.inDegree.set(taskId, 0);
    }

    // Add edges from dependencies
    for (const [taskId, deps] of this.dependencies) {
      for (const depId of deps) {
        // Validate dependency exists
        if (!this.tasks.has(depId)) {
          throw new Error(
            `Task "${taskId}" depends on unknown task "${depId}"`
          );
        }

        // Add edge: depId -> taskId (depId must complete before taskId)
        graph.edges.get(depId).add(taskId);
        graph.inDegree.set(taskId, graph.inDegree.get(taskId) + 1);
      }
    }

    this.graph = graph;
    return graph;
  }

  /**
   * Detect circular dependencies using DFS
   */
  detectCircular() {
    if (!this.graph) {
      this.buildGraph();
    }

    const visiting = new Set();
    const visited = new Set();
    const cycles = [];

    const dfs = (taskId, path = []) => {
      if (visiting.has(taskId)) {
        // Found a cycle
        const cycleStart = path.indexOf(taskId);
        cycles.push([...path.slice(cycleStart), taskId]);
        return true;
      }

      if (visited.has(taskId)) {
        return false;
      }

      visiting.add(taskId);
      path.push(taskId);

      const dependents = this.graph.edges.get(taskId) || new Set();
      for (const depId of dependents) {
        dfs(depId, [...path]);
      }

      visiting.delete(taskId);
      visited.add(taskId);
      return false;
    };

    for (const taskId of this.graph.nodes) {
      if (!visited.has(taskId)) {
        dfs(taskId);
      }
    }

    return cycles;
  }

  /**
   * Resolve execution order using topological sort (Kahn's algorithm)
   */
  resolve() {
    if (!this.graph) {
      this.buildGraph();
    }

    // Check for circular dependencies first
    const cycles = this.detectCircular();
    if (cycles.length > 0) {
      throw new Error(
        `Circular dependencies detected:\n${cycles.map(c => c.join(' -> ')).join('\n')}`
      );
    }

    const result = {
      stages: [],
      order: [],
      parallelizable: []
    };

    // Clone in-degree map for processing
    const inDegree = new Map(this.graph.inDegree);
    const processed = new Set();

    while (processed.size < this.graph.nodes.size) {
      // Find all tasks with no dependencies (in-degree = 0)
      const ready = [];
      for (const [taskId, degree] of inDegree) {
        if (degree === 0 && !processed.has(taskId)) {
          ready.push(taskId);
        }
      }

      if (ready.length === 0) {
        throw new Error('Unable to resolve dependencies - possible cycle');
      }

      // This stage can run in parallel
      result.stages.push(ready);
      result.parallelizable.push(ready.length > 1);

      // Process ready tasks
      for (const taskId of ready) {
        result.order.push(taskId);
        processed.add(taskId);

        // Reduce in-degree for dependent tasks
        const dependents = this.graph.edges.get(taskId) || new Set();
        for (const depId of dependents) {
          inDegree.set(depId, inDegree.get(depId) - 1);
        }
      }
    }

    return result;
  }

  /**
   * Get tasks ready to execute (no pending dependencies)
   */
  getReadyTasks(completedTaskIds = []) {
    const completed = new Set(completedTaskIds);
    const ready = [];

    for (const [taskId, deps] of this.dependencies) {
      if (completed.has(taskId)) {
        continue; // Already completed
      }

      // Check if all dependencies are completed
      const allDepsMet = deps.every(depId => completed.has(depId));
      if (allDepsMet) {
        ready.push(this.tasks.get(taskId));
      }
    }

    return ready;
  }

  /**
   * Visualize dependency graph
   */
  visualize() {
    if (!this.graph) {
      this.buildGraph();
    }

    const lines = [];
    lines.push('Dependency Graph:');
    lines.push('');

    for (const [taskId, deps] of this.dependencies) {
      const task = this.tasks.get(taskId);
      lines.push(`${taskId}: ${task.name}`);

      if (deps.length > 0) {
        lines.push(`  Depends on: ${deps.join(', ')}`);
      }

      const dependents = this.graph.edges.get(taskId) || new Set();
      if (dependents.size > 0) {
        lines.push(`  Required by: ${[...dependents].join(', ')}`);
      }

      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Get execution stages for visualization
   */
  getStages() {
    const resolution = this.resolve();
    return resolution.stages.map((stage, index) => ({
      stage: index + 1,
      tasks: stage.map(id => ({
        id,
        name: this.tasks.get(id).name
      })),
      parallel: stage.length > 1
    }));
  }

  /**
   * Reset resolver
   */
  reset() {
    this.tasks.clear();
    this.dependencies.clear();
    this.graph = null;
  }
}

export default DependencyResolver;
```

**Verify:**
- [ ] DependencyResolver exports correctly
- [ ] Parses dependencies from various formats
- [ ] Builds dependency graph correctly
- [ ] Detects circular dependencies
- [ ] Resolves execution order via topological sort
- [ ] Returns parallel execution stages

**Done:** [ ]

---

### Task 2: Integrate with AgentPool

**Type:** modify
**Files:** `momentum/lib/core/agent-pool.js`
**Action:** Add dependency-aware task distribution

Add import:
```javascript
import { DependencyResolver } from './dependency-resolver.js';
```

Add dependency resolver to constructor:
```javascript
this.resolver = new DependencyResolver();
```

Update distribute method to respect dependencies:
```javascript
/**
 * Distribute tasks across available agents (dependency-aware)
 */
async distribute(tasks, options = {}) {
  const respectDependencies = options.dependencies !== false;

  if (respectDependencies) {
    return this.distributeWithDependencies(tasks);
  } else {
    // Original behavior - no dependency checking
    this.addTasks(tasks);
    return this.start();
  }
}

/**
 * Distribute tasks respecting dependencies
 */
async distributeWithDependencies(tasks) {
  // Build dependency graph
  this.resolver.reset();
  this.resolver.addTasks(tasks);

  // Get execution stages
  const resolution = this.resolver.resolve();

  this.emit('dependency:resolved', {
    stages: resolution.stages.length,
    order: resolution.order
  });

  // Execute stage by stage
  const allResults = {};

  for (let i = 0; i < resolution.stages.length; i++) {
    const stage = resolution.stages[i];
    const stageTasks = stage.map(taskId =>
      tasks.find(t => t.id === taskId)
    );

    this.emit('stage:start', {
      stage: i + 1,
      total: resolution.stages.length,
      tasks: stage,
      parallel: resolution.parallelizable[i]
    });

    // Execute this stage (can run in parallel)
    this.addTasks(stageTasks);
    const stageResults = await this.start();

    Object.assign(allResults, stageResults);

    this.emit('stage:complete', {
      stage: i + 1,
      results: stageResults
    });

    // Check for failures
    const failures = Object.values(stageResults).filter(r => !r.success);
    if (failures.length > 0 && options.stopOnFailure !== false) {
      throw new Error(
        `Stage ${i + 1} failed: ${failures.length} task(s) failed`
      );
    }
  }

  return allResults;
}
```

**Verify:**
- [ ] AgentPool uses DependencyResolver
- [ ] Tasks execute in dependency order
- [ ] Parallel stages execute simultaneously
- [ ] Sequential stages wait for completion
- [ ] Failures are handled correctly

**Done:** [ ]

---

### Task 3: Add Dependency Visualization Command

**Type:** create
**Files:** `momentum/commands/deps.md`
**Action:** Create slash command for dependency visualization

```markdown
---
description: Visualize task dependencies and execution order
arguments:
  - name: action
    description: "Action: show, check, stages"
    required: true
  - name: plan
    description: "Path to plan file (optional)"
    required: false
---

# Dependency Visualization

Analyze and visualize task dependencies for a plan.

## Actions

### show [plan-path]
Display the dependency graph for tasks in a plan.

Example:
```
/deps show ./ae-cc/planning/phases/02-multi-agent/02-03-PLAN.md
```

Output:
```
Dependency Graph:

task-1: Create DependencyResolver Class
  Required by: task-2, task-3

task-2: Integrate with AgentPool
  Depends on: task-1
  Required by: task-3

task-3: Add Dependency Visualization
  Depends on: task-1, task-2
```

### check [plan-path]
Check for circular dependencies and validation errors.

Example:
```
/deps check
```

### stages [plan-path]
Show execution stages with parallel opportunities.

Example:
```
/deps stages
```

Output:
```
Execution Plan:

Stage 1 (parallel: no):
  - task-1: Create DependencyResolver Class

Stage 2 (parallel: yes):
  - task-2: Integrate with AgentPool
  - task-3: Add Dependency Visualization
```

## Context
@momentum/lib/core/dependency-resolver.js
@momentum/lib/core/agent-pool.js

## Implementation Notes

Dependency formats supported:
1. `dependsOn` field in task metadata
2. "depends on: task-1, task-2" in task description
3. `metadata.dependencies` array

Circular dependencies are detected and reported before execution.
```

**Verify:**
- [ ] Command file created
- [ ] All actions documented
- [ ] Examples provided

**Done:** [ ]

---

## Verification Steps

1. [ ] Create plan with 4 tasks in dependency chain
2. [ ] Add task with circular dependency
3. [ ] Verify circular dependency detected
4. [ ] Remove circular dependency
5. [ ] Resolve execution order
6. [ ] Verify topological sort correct
7. [ ] Execute with AgentPool
8. [ ] Verify stages execute in order
9. [ ] Verify parallel tasks run simultaneously

## Success Criteria

- Dependencies parsed from multiple formats
- Dependency graph built correctly
- Circular dependencies detected
- Execution order resolved via topological sort
- Parallel execution stages identified
- AgentPool respects dependency order
- Clean visualization of dependency graph
- No race conditions in dependent tasks

## Output

Create `02-03-SUMMARY.md` with:
- Implementation details
- Dependency resolution algorithm explanation
- Performance characteristics
- Example dependency graphs
- Integration with AgentPool

---

*Generated by Momentum Planning*
