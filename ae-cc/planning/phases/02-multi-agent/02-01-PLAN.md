# Phase 2, Plan 1: Multi-Agent Orchestrator - Core Architecture

## Objective

Implement the `AgentPool` class to enable true parallel execution via multiple Claude Code processes, each operating in isolated git worktrees.

## Context

**Why Multi-Agent?**
- Current executor simulates parallelism but runs sequentially
- Real parallelism enables massive throughput (4-12x speedup)
- Each agent gets dedicated worktree for isolation
- Results merge back cleanly via worktree merge

**Dependencies:**
- Phase 1 (Worktrees) must be complete
- Node.js child_process for spawning

## Tasks

### Task 1: Create AgentPool Class

**Type:** create
**Files:** `momentum/lib/core/agent-pool.js`
**Action:** Create the multi-agent orchestration class

```javascript
/**
 * AgentPool - Multi-agent parallel execution orchestrator
 */
import { spawn, fork } from 'child_process';
import { EventEmitter } from 'events';
import { WorktreeManager } from './worktree.js';

export class AgentPool extends EventEmitter {
  constructor(options = {}) {
    super();
    this.maxAgents = options.maxAgents || 4;
    this.agents = new Map();
    this.taskQueue = [];
    this.results = new Map();
    this.worktreeManager = null;
  }

  /**
   * Initialize the pool with a repository
   */
  async init(repoDir) {
    this.repoDir = repoDir;
    this.worktreeManager = new WorktreeManager(repoDir);
    this.worktreeManager.init();
    return this;
  }

  /**
   * Add tasks to the queue
   */
  addTasks(tasks) {
    this.taskQueue.push(...tasks);
    return this;
  }

  /**
   * Spawn an agent for a specific task
   */
  async spawn(task) {
    const taskId = task.id || `task-${Date.now()}`;

    // Create worktree for this agent
    const worktree = await this.worktreeManager.create(taskId);

    // Prepare agent process
    const agent = {
      id: taskId,
      task,
      worktree,
      process: null,
      status: 'starting',
      output: [],
      startTime: Date.now()
    };

    // Spawn Claude Code process
    // Uses claude CLI in the worktree directory
    const process = spawn('claude', [
      '--dangerously-skip-permissions',
      '--print',
      task.prompt || `Execute task: ${task.name}`
    ], {
      cwd: worktree.path,
      shell: true,
      stdio: ['pipe', 'pipe', 'pipe']
    });

    agent.process = process;
    agent.status = 'running';

    // Capture output
    process.stdout.on('data', (data) => {
      agent.output.push(data.toString());
      this.emit('agent:output', { taskId, data: data.toString() });
    });

    process.stderr.on('data', (data) => {
      agent.output.push(`[stderr] ${data.toString()}`);
      this.emit('agent:error', { taskId, data: data.toString() });
    });

    // Handle completion
    process.on('close', async (code) => {
      agent.status = code === 0 ? 'completed' : 'failed';
      agent.endTime = Date.now();
      agent.exitCode = code;

      this.results.set(taskId, {
        success: code === 0,
        output: agent.output.join(''),
        duration: agent.endTime - agent.startTime,
        worktree: worktree.path
      });

      this.emit('agent:complete', { taskId, code, agent });
      this.agents.delete(taskId);

      // Process next task if available
      this.processQueue();
    });

    this.agents.set(taskId, agent);
    this.emit('agent:spawn', { taskId, task });

    return agent;
  }

  /**
   * Distribute tasks across available agents
   */
  async distribute(tasks) {
    this.addTasks(tasks);
    return this.start();
  }

  /**
   * Start processing the queue
   */
  async start() {
    const promises = [];

    // Initial batch
    while (this.agents.size < this.maxAgents && this.taskQueue.length > 0) {
      const task = this.taskQueue.shift();
      promises.push(this.spawn(task));
    }

    await Promise.all(promises);

    // Wait for all to complete
    return new Promise((resolve) => {
      const checkComplete = () => {
        if (this.agents.size === 0 && this.taskQueue.length === 0) {
          resolve(this.getResults());
        }
      };

      this.on('agent:complete', checkComplete);
      checkComplete(); // In case already done
    });
  }

  /**
   * Process next task in queue
   */
  processQueue() {
    if (this.agents.size < this.maxAgents && this.taskQueue.length > 0) {
      const task = this.taskQueue.shift();
      this.spawn(task);
    }
  }

  /**
   * Get all results
   */
  getResults() {
    return Object.fromEntries(this.results);
  }

  /**
   * Monitor agent health
   */
  monitor() {
    const status = [];
    for (const [id, agent] of this.agents) {
      status.push({
        id,
        status: agent.status,
        runtime: Date.now() - agent.startTime,
        worktree: agent.worktree.name
      });
    }
    return status;
  }

  /**
   * Kill all agents
   */
  async killAll() {
    for (const [id, agent] of this.agents) {
      if (agent.process) {
        agent.process.kill('SIGTERM');
      }
    }
    this.agents.clear();
  }

  /**
   * Merge all completed worktrees back to main
   */
  async mergeAll(target = 'main') {
    const results = [];
    for (const [taskId, result] of this.results) {
      if (result.success) {
        const mergeResult = await this.worktreeManager.merge(taskId, target);
        results.push({ taskId, ...mergeResult });
      }
    }
    return results;
  }

  /**
   * Cleanup all worktrees
   */
  async cleanup() {
    for (const [taskId] of this.results) {
      try {
        await this.worktreeManager.delete(taskId);
      } catch {
        // Already cleaned
      }
    }
  }
}

export default AgentPool;
```

**Verify:**
- [ ] Class exports correctly
- [ ] Events emit properly
- [ ] Process spawning works

**Done:** [ ]

---

### Task 2: Create Agent Worker Process

**Type:** create
**Files:** `momentum/lib/core/agent-worker.js`
**Action:** Create worker process for agent execution

```javascript
/**
 * Agent Worker - Isolated process for task execution
 *
 * This runs in its own process, receives task via IPC,
 * and executes via Claude Code CLI.
 */
import { execSync } from 'child_process';

// Receive task from parent
process.on('message', async (message) => {
  if (message.type === 'execute') {
    const { task, worktreePath } = message;

    try {
      // Execute task in worktree
      const result = execSync(`claude --print "${task.prompt}"`, {
        cwd: worktreePath,
        encoding: 'utf8',
        maxBuffer: 50 * 1024 * 1024 // 50MB buffer
      });

      // Report success
      process.send({
        type: 'complete',
        taskId: task.id,
        success: true,
        output: result
      });

    } catch (err) {
      // Report failure
      process.send({
        type: 'complete',
        taskId: task.id,
        success: false,
        error: err.message,
        output: err.stdout || ''
      });
    }
  }
});

// Signal ready
process.send({ type: 'ready' });
```

**Verify:**
- [ ] Worker process starts
- [ ] IPC communication works
- [ ] Error handling correct

**Done:** [ ]

---

### Task 3: Add CLI Commands for Pool Management

**Type:** create
**Files:** `momentum/commands/agents.md`
**Action:** Create slash command for agent pool management

```markdown
---
description: Manage the multi-agent execution pool
arguments:
  - name: action
    description: "Action: status, kill, config"
    required: true
---

# Agent Pool Management

Monitor and control the multi-agent execution pool.

## Actions

### status
Show running agents, queue depth, completed tasks.

### kill [id]
Kill a specific agent or all agents.

### config [key] [value]
Configure pool settings (maxAgents, timeout).

## Context
@momentum/lib/core/agent-pool.js
```

**Verify:**
- [ ] Command file created
- [ ] All actions documented

**Done:** [ ]

---

### Task 4: Update Executor for Multi-Agent Support

**Type:** modify
**Files:** `momentum/lib/core/executor.js`
**Action:** Integrate AgentPool with parallel execution

Replace simulated parallel with real parallel:

```javascript
// In executeParallel() method:
async executeParallel(plan, config) {
  const { AgentPool } = await import('./agent-pool.js');
  const pool = new AgentPool({
    maxAgents: config.features?.maxAgents || 4
  });

  await pool.init(this.dir);

  // Convert tasks to agent tasks
  const agentTasks = plan.tasks.map(task => ({
    id: task.id,
    name: task.name,
    prompt: this.buildTaskPrompt(task, plan)
  }));

  // Subscribe to events
  pool.on('agent:spawn', ({ taskId }) => {
    info(`Agent spawned: ${taskId}`);
  });

  pool.on('agent:complete', ({ taskId, code }) => {
    const status = code === 0 ? 'completed' : 'failed';
    taskStatus(taskId, status);
  });

  // Execute all
  const results = await pool.distribute(agentTasks);

  // Merge successful results
  const mergeResults = await pool.mergeAll();

  // Cleanup
  await pool.cleanup();

  // Update task statuses
  for (const task of plan.tasks) {
    const result = results[task.id];
    task.status = result?.success ? 'completed' : 'failed';
    task.error = result?.error;
  }
}

/**
 * Build prompt for agent
 */
buildTaskPrompt(task, plan) {
  return `
## Task: ${task.name}

${task.description}

### Files to modify:
${task.files.join('\n')}

### Context:
${plan.context}

### Verification:
${task.verification}

Execute this task. Commit changes when complete.
`;
}
```

**Verify:**
- [ ] Executor uses AgentPool
- [ ] Tasks distributed correctly
- [ ] Results merged properly

**Done:** [ ]

---

## Verification Steps

1. [ ] Create 4 independent tasks
2. [ ] Run with `momentum execute --parallel`
3. [ ] Verify 4 agents spawn
4. [ ] Verify each has own worktree
5. [ ] Verify results merge correctly
6. [ ] Verify cleanup happens

## Success Criteria

- Multiple agents run truly in parallel
- Each agent isolated in worktree
- Results merge cleanly
- Graceful failure handling
- No main branch pollution

## Output

Create `02-01-SUMMARY.md` with:
- Implementation details
- Performance measurements (parallel vs sequential)
- Any edge cases discovered
- Next steps for QA integration

---

*Generated by Momentum Planning*
