# Phase 2, Plan 2: Agent-to-Agent Communication

## Objective

Implement the `AgentBus` class to enable event-based message passing between agents, allowing for coordination and data sharing during parallel execution.

## Context

**Why Agent Communication?**
- Agents need to share intermediate results
- Coordination for dependent tasks
- Real-time status updates between agents
- Enable collaborative problem-solving patterns

**Dependencies:**
- Phase 2, Plan 1 (AgentPool) must be complete
- EventEmitter pattern for message passing

## Tasks

### Task 1: Create AgentBus Class

**Type:** create
**Files:** `momentum/lib/core/agent-bus.js`
**Action:** Create event-based message bus for agent communication

```javascript
/**
 * AgentBus - Event-based message passing between agents
 */
import { EventEmitter } from 'events';
import { writeFileSync, readFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';

export class AgentBus extends EventEmitter {
  constructor(options = {}) {
    super();
    this.persistPath = options.persistPath || '.momentum/messages';
    this.messages = [];
    this.messageId = 0;
    this.subscribers = new Map();

    // Ensure persist directory exists
    if (!existsSync(this.persistPath)) {
      mkdirSync(this.persistPath, { recursive: true });
    }

    this.loadPersistedMessages();
  }

  /**
   * Broadcast message to all agents
   */
  broadcast(fromAgent, message) {
    const msg = {
      id: ++this.messageId,
      from: fromAgent,
      to: 'all',
      message,
      timestamp: Date.now(),
      type: 'broadcast'
    };

    this.messages.push(msg);
    this.persist(msg);
    this.emit('message', msg);
    this.emit('broadcast', msg);

    return msg.id;
  }

  /**
   * Send message to specific agent
   */
  send(fromAgent, toAgent, message) {
    const msg = {
      id: ++this.messageId,
      from: fromAgent,
      to: toAgent,
      message,
      timestamp: Date.now(),
      type: 'direct'
    };

    this.messages.push(msg);
    this.persist(msg);
    this.emit('message', msg);
    this.emit(`message:${toAgent}`, msg);

    return msg.id;
  }

  /**
   * Subscribe to messages for specific agent
   */
  onMessage(agentId, callback) {
    const handler = (msg) => {
      if (msg.to === agentId || msg.to === 'all') {
        callback(msg);
      }
    };

    this.on('message', handler);
    this.subscribers.set(agentId, handler);

    return () => this.off('message', handler);
  }

  /**
   * Get all messages for an agent
   */
  getMessages(agentId, options = {}) {
    let filtered = this.messages.filter(
      msg => msg.to === agentId || msg.to === 'all'
    );

    if (options.since) {
      filtered = filtered.filter(msg => msg.timestamp > options.since);
    }

    if (options.from) {
      filtered = filtered.filter(msg => msg.from === options.from);
    }

    if (options.type) {
      filtered = filtered.filter(msg => msg.type === options.type);
    }

    return filtered;
  }

  /**
   * Get message history
   */
  getHistory(limit = 100) {
    return this.messages.slice(-limit);
  }

  /**
   * Clear all messages
   */
  clear() {
    this.messages = [];
    this.messageId = 0;
  }

  /**
   * Persist message to disk
   */
  persist(message) {
    const filepath = join(this.persistPath, `${message.id}.json`);
    writeFileSync(filepath, JSON.stringify(message, null, 2));
  }

  /**
   * Load persisted messages from disk
   */
  loadPersistedMessages() {
    if (!existsSync(this.persistPath)) {
      return;
    }

    const files = require('fs').readdirSync(this.persistPath);
    const messages = files
      .filter(f => f.endsWith('.json'))
      .map(f => {
        try {
          const content = readFileSync(join(this.persistPath, f), 'utf8');
          return JSON.parse(content);
        } catch {
          return null;
        }
      })
      .filter(m => m !== null)
      .sort((a, b) => a.id - b.id);

    this.messages = messages;
    this.messageId = messages.length > 0
      ? Math.max(...messages.map(m => m.id))
      : 0;
  }

  /**
   * Clean up old messages
   */
  cleanup(olderThan = 24 * 60 * 60 * 1000) { // 24 hours default
    const cutoff = Date.now() - olderThan;
    this.messages = this.messages.filter(msg => msg.timestamp > cutoff);
  }
}

export default AgentBus;
```

**Verify:**
- [ ] AgentBus exports correctly
- [ ] Messages persist to disk
- [ ] Broadcast works
- [ ] Direct messaging works
- [ ] Message filtering works

**Done:** [ ]

---

### Task 2: Integrate AgentBus with AgentPool

**Type:** modify
**Files:** `momentum/lib/core/agent-pool.js`
**Action:** Add communication methods to AgentPool

Add import and initialization:
```javascript
import { AgentBus } from './agent-bus.js';

// In constructor:
this.bus = new AgentBus({ persistPath: '.momentum/messages' });
```

Add communication methods:
```javascript
/**
 * Broadcast message to all agents
 */
broadcast(fromAgent, message) {
  return this.bus.broadcast(fromAgent, message);
}

/**
 * Send message to specific agent
 */
send(fromAgent, toAgent, message) {
  return this.bus.send(fromAgent, toAgent, message);
}

/**
 * Subscribe to messages for agent
 */
onMessage(agentId, callback) {
  return this.bus.onMessage(agentId, callback);
}

/**
 * Get messages for agent
 */
getMessages(agentId, options) {
  return this.bus.getMessages(agentId, options);
}

/**
 * Get message history
 */
getMessageHistory(limit) {
  return this.bus.getHistory(limit);
}
```

Add event forwarding in spawn method:
```javascript
// After setting up agent process, add:
this.bus.on('message', (msg) => {
  if (msg.to === taskId || msg.to === 'all') {
    this.emit('agent:message', { taskId, message: msg });
  }
});
```

**Verify:**
- [ ] AgentPool exposes communication methods
- [ ] Messages are forwarded to agents
- [ ] Event emissions work correctly

**Done:** [ ]

---

### Task 3: Create Agent Messaging CLI Command

**Type:** create
**Files:** `momentum/commands/agents-msg.md`
**Action:** Create slash command for agent messaging operations

```markdown
---
description: Send messages between agents and view message history
arguments:
  - name: action
    description: "Action: send, broadcast, history, clear"
    required: true
  - name: args
    description: "Action-specific arguments"
    required: false
---

# Agent Messaging

Send and receive messages between running agents.

## Actions

### send <from-agent> <to-agent> <message>
Send a direct message from one agent to another.

Example:
```
/agents-msg send agent-1 agent-2 "Share your progress on the API implementation"
```

### broadcast <from-agent> <message>
Broadcast a message to all agents.

Example:
```
/agents-msg broadcast coordinator "All agents: commit your current work"
```

### history [agent-id] [limit]
View message history. Optionally filter by agent ID and limit results.

Example:
```
/agents-msg history agent-1 50
```

### clear
Clear all message history.

## Context
@momentum/lib/core/agent-bus.js
@momentum/lib/core/agent-pool.js

## Implementation Notes

Messages are:
- Persisted to `.momentum/messages/` directory
- Kept for 24 hours by default
- Available across agent restarts
- Queryable by time, sender, recipient, or type
```

**Verify:**
- [ ] Command file created
- [ ] All actions documented
- [ ] Examples provided

**Done:** [ ]

---

## Verification Steps

1. [ ] Create AgentPool with 2 agents
2. [ ] Broadcast message from agent-1
3. [ ] Verify agent-2 receives broadcast
4. [ ] Send direct message from agent-1 to agent-2
5. [ ] Verify only agent-2 receives direct message
6. [ ] Check message persistence in `.momentum/messages/`
7. [ ] Restart and verify messages loaded
8. [ ] Query message history with filters

## Success Criteria

- Agents can broadcast to all agents
- Agents can send targeted messages
- Messages persist across restarts
- Message history is queryable
- No message loss during failures
- Clean API for messaging operations

## Output

Create `02-02-SUMMARY.md` with:
- Implementation details
- Message flow diagrams
- Performance characteristics
- Usage examples
- Integration with AgentPool

---

*Generated by Momentum Planning*
