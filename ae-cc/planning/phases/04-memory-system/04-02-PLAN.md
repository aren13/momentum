# Plan 04-02: Pattern Learning and Decision Caching

**Phase:** 4 - Memory System
**Plan:** 04-02
**Objective:** Implement intelligent pattern learning and decision caching to improve execution efficiency

---

## Context

Building on the MemoryStore foundation (Plan 04-01), this plan adds intelligence to Momentum by:
1. Learning from successful executions and extracting reusable patterns
2. Caching decisions to avoid re-asking the same questions
3. Integrating with the executor to automatically record and utilize memory

**Key Benefits:**
- Faster execution (cached decisions skip LLM calls)
- Better suggestions (learned patterns guide future work)
- Progressive improvement (system gets smarter over time)

---

## Tasks

### Task 1: Create PatternLearner class
**File:** `momentum/lib/core/pattern-learner.js`

**Requirements:**
- Extract patterns from successful plan executions
- Pattern types to learn:
  - `file-structure`: Directory and file organization patterns
  - `naming-convention`: Variable/function/file naming patterns
  - `import-pattern`: Import/export patterns
  - `error-resolution`: Common error fixes
  - `test-pattern`: Testing approaches
  - `commit-pattern`: Commit message styles
- Store pattern frequency and success rate
- Suggest relevant patterns for similar tasks
- Pattern matching with fuzzy search
- Confidence scoring for suggestions

**Implementation Structure:**
```javascript
class PatternLearner {
  constructor(memoryStore) {
    this.store = memoryStore;
  }

  // Extract patterns from execution result
  async learnFromExecution(execution) {
    const patterns = await this.extractPatterns(execution);
    for (const { type, pattern } of patterns) {
      await this.store.addPattern(type, pattern);
    }
  }

  // Extract patterns from file changes
  async extractPatterns(execution) {
    // Analyze: file structure, naming, imports, etc.
  }

  // Get pattern suggestions for current context
  async suggestPatterns(context) {
    const relevant = await this.findRelevantPatterns(context);
    return relevant.map(p => ({
      pattern: p.pattern,
      type: p.type,
      confidence: this.calculateConfidence(p, context),
      frequency: p.frequency
    }));
  }

  // Find patterns similar to current context
  async findRelevantPatterns(context) {
    // Use fuzzy matching on pattern content
    // Score by frequency and recency
  }

  // Calculate confidence for pattern suggestion
  calculateConfidence(pattern, context) {
    // Factor in: frequency, recency, similarity, success rate
  }
}
```

**Pattern Extraction Logic:**

1. **File Structure Patterns:**
   - Directory organization: `lib/core/`, `commands/`, `tests/`
   - File grouping: related files in same directory
   - Naming patterns: kebab-case, camelCase, PascalCase

2. **Naming Convention Patterns:**
   - Variable names: `camelCase`, `snake_case`
   - Function names: verb prefixes (get, set, create, update)
   - Class names: `PascalCase`, suffixes (Manager, Store, Runner)

3. **Import Patterns:**
   - Import order: external, internal, relative
   - Destructuring patterns
   - Default vs named exports

4. **Error Resolution Patterns:**
   - Common error messages → fixes
   - Lint errors → auto-fix patterns
   - Test failures → resolution patterns

5. **Test Patterns:**
   - Test file naming: `*.test.js`, `*.spec.js`
   - Test structure: describe/it blocks
   - Assertion patterns

6. **Commit Patterns:**
   - Message format: `type(scope): description`
   - Common types: feat, fix, docs, refactor
   - Scope patterns

**Verification:**
- [ ] Patterns extracted from successful executions
- [ ] Pattern frequency tracked correctly
- [ ] Suggestions relevant to context
- [ ] Confidence scores make sense
- [ ] Fuzzy matching works

---

### Task 2: Create DecisionCache class
**File:** `momentum/lib/core/decision-cache.js`

**Requirements:**
- Hash context to create deterministic cache keys
- Store decisions with context metadata
- Retrieve cached decisions efficiently
- TTL-based expiration (configurable, default: 24 hours)
- Invalidation strategies:
  - Manual: `invalidate(contextHash)`
  - Automatic: TTL expiration
  - Selective: by pattern or context type
- Cache statistics:
  - Hit rate
  - Total cached decisions
  - Average age
  - Storage size

**Implementation Structure:**
```javascript
import crypto from 'crypto';

class DecisionCache {
  constructor(memoryStore, ttlHours = 24) {
    this.store = memoryStore;
    this.ttl = ttlHours * 60 * 60 * 1000; // Convert to ms
  }

  // Hash context to create cache key
  hashContext(context, question) {
    const normalized = this.normalizeContext(context);
    const input = JSON.stringify({ context: normalized, question });
    return crypto.createHash('sha256').update(input).digest('hex');
  }

  // Normalize context for consistent hashing
  normalizeContext(context) {
    // Remove timestamps, sort keys, trim whitespace
    // Ensure consistent structure
  }

  // Cache a decision
  async cacheDecision(context, question, answer) {
    const hash = this.hashContext(context, question);
    await this.store.cacheDecision(hash, question, answer);
  }

  // Retrieve cached decision
  async getCachedDecision(context, question) {
    const hash = this.hashContext(context, question);
    const cached = await this.store.getCachedDecision(hash);

    if (!cached) return null;

    // Check TTL
    const age = Date.now() - new Date(cached.timestamp).getTime();
    if (age > this.ttl) {
      await this.invalidate(hash);
      return null;
    }

    return cached.answer;
  }

  // Invalidate cache entry
  async invalidate(contextHash) {
    await this.store.deleteCachedDecision(contextHash);
  }

  // Clear expired entries
  async clearExpired() {
    const cutoff = new Date(Date.now() - this.ttl);
    await this.store.deleteExpiredDecisions(cutoff);
  }

  // Get cache statistics
  async getStats() {
    return {
      total: await this.store.countDecisions(),
      hitRate: await this.calculateHitRate(),
      avgAge: await this.calculateAverageAge(),
      size: await this.store.getCacheSize()
    };
  }
}
```

**Context Normalization:**
- Remove timestamps and UUIDs
- Sort object keys alphabetically
- Trim whitespace
- Convert paths to relative
- Ignore volatile metadata

**Cache Key Strategy:**
```javascript
// Example cache key creation
const context = {
  planPath: './ae-cc/planning/phases/04-memory-system/04-01-PLAN.md',
  taskIndex: 1,
  codebase: {
    language: 'javascript',
    framework: null
  }
};

const question = "What naming convention should I use for this class?";
const hash = hashContext(context, question);
// → "a7f3c9d8e2b1..." (deterministic)
```

**Verification:**
- [ ] Cache hits return correct answers
- [ ] Cache misses return null
- [ ] TTL expiration works
- [ ] Context normalization consistent
- [ ] Statistics accurate

---

### Task 3: Integrate with executor
**File:** `momentum/lib/core/executor.js` (modify existing)

**Requirements:**
- Initialize PatternLearner and DecisionCache
- Record execution patterns after successful runs
- Use cached decisions when available
- Learn from execution outcomes
- Update memory statistics
- Optional: Show cache hit/miss in progress output

**Integration Points:**

1. **Initialization:**
```javascript
import { MemoryStore } from './memory-store.js';
import { PatternLearner } from './pattern-learner.js';
import { DecisionCache } from './decision-cache.js';

class Executor {
  constructor(planPath, options = {}) {
    this.planPath = planPath;
    this.options = options;

    // Initialize memory system
    this.memory = new MemoryStore();
    this.patternLearner = new PatternLearner(this.memory);
    this.decisionCache = new DecisionCache(this.memory);
  }
}
```

2. **Before Execution:**
```javascript
async prepareExecution() {
  // Check for cached decisions
  const cachedPlan = await this.decisionCache.getCachedDecision(
    { planPath: this.planPath },
    'execution-strategy'
  );

  if (cachedPlan) {
    this.log('Using cached execution strategy');
    return cachedPlan;
  }

  // Get pattern suggestions
  const suggestions = await this.patternLearner.suggestPatterns({
    planPath: this.planPath,
    fileTypes: this.detectFileTypes()
  });

  if (suggestions.length > 0) {
    this.log('Pattern suggestions:', suggestions);
  }
}
```

3. **After Execution:**
```javascript
async recordExecution(result) {
  // Record execution in memory
  await this.memory.recordExecution(
    this.planPath,
    result.duration,
    result.success,
    result.errors
  );

  // Learn patterns from successful execution
  if (result.success) {
    await this.patternLearner.learnFromExecution(result);
  }

  // Cache the execution strategy
  await this.decisionCache.cacheDecision(
    { planPath: this.planPath },
    'execution-strategy',
    result.strategy
  );
}
```

4. **Pattern-Aware File Generation:**
```javascript
async generateFile(path, content) {
  // Get naming suggestions
  const namingPatterns = await this.patternLearner.suggestPatterns({
    type: 'naming-convention',
    path: path
  });

  // Get import patterns
  const importPatterns = await this.patternLearner.suggestPatterns({
    type: 'import-pattern',
    path: path
  });

  // Use patterns to inform generation
  // (This would be enhanced in future with LLM integration)
}
```

**Configuration:**
Add to `momentum/config/default.json`:
```json
{
  "memory": {
    "enabled": true,
    "dbPath": ".momentum/memory.db",
    "cacheTTL": 24,
    "learningEnabled": true,
    "autoCleanup": true
  }
}
```

**Verification:**
- [ ] Executor initializes memory system
- [ ] Patterns learned from executions
- [ ] Decisions cached correctly
- [ ] Cache hits skip redundant work
- [ ] Memory stats updated
- [ ] Configuration works

---

## Dependencies

**Uses:**
- `MemoryStore` from Plan 04-01
- Existing `Executor` class
- Existing `ProgressReporter` for logging

**No Additional NPM Packages Required**

---

## Success Criteria

- [ ] PatternLearner extracts meaningful patterns
- [ ] Pattern suggestions are relevant and useful
- [ ] DecisionCache speeds up repeated operations
- [ ] Cache hit rate improves over time
- [ ] Executor integration is seamless
- [ ] Memory usage stays reasonable (<10 MB)
- [ ] No performance degradation

---

## Testing Strategy

1. **Unit Tests:**
   - Test pattern extraction logic
   - Test context hashing
   - Test cache hit/miss
   - Test TTL expiration

2. **Integration Tests:**
   - Run same plan twice (verify cache hit)
   - Run similar plans (verify pattern suggestions)
   - Test learning from multiple executions

3. **Performance Tests:**
   - Measure cache lookup time (<10ms)
   - Measure pattern matching time (<50ms)
   - Test with 1000+ cached decisions

4. **Manual Testing:**
   - Execute a plan, then execute again (should be faster)
   - View memory stats after multiple runs
   - Export memory and verify learned patterns

---

## Future Enhancements

- **Semantic Search:** Add embeddings for semantic pattern matching
- **Conflict Detection:** Learn from merge conflicts and suggest resolutions
- **Code Quality Patterns:** Track code quality metrics over time
- **Team Learning:** Share pattern databases across team
- **LLM Integration:** Use patterns to enhance prompts (Phase 6)

---

**Estimated Time:** 4-5 hours
**Complexity:** Medium-High
**Priority:** High (Completes Phase 4)
**Depends On:** Plan 04-01 (MemoryStore)
