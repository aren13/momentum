# Plan 04-01: Core MemoryStore with SQLite

**Phase:** 4 - Memory System
**Plan:** 04-01
**Objective:** Implement portable memory persistence using SQLite for pattern learning and decision caching

---

## Context

Momentum needs to persist knowledge across sessions without external dependencies like Docker or FalkorDB. This plan implements a lightweight SQLite-based memory system that stores patterns, decisions, execution history, and file metadata.

**Design Principles:**
- Zero external dependencies (SQLite ships with Node.js via better-sqlite3)
- Portable `.momentum/memory.db` file
- Fast queries (sub-100ms)
- Auto-migration on schema changes
- Export/import for backup and sharing

---

## Tasks

### Task 1: Create MemoryStore class
**File:** `momentum/lib/core/memory-store.js`

**Requirements:**
- SQLite database at `.momentum/memory.db`
- Four core tables:
  - `patterns`: Learned patterns from executions (type, pattern, frequency, last_seen)
  - `decisions`: Cached decisions with context hashing (context_hash, question, answer, timestamp)
  - `executions`: Execution history (plan_path, duration, success, errors, timestamp)
  - `files`: File metadata (path, last_analyzed, summary_hash, patterns)
- CRUD operations for each table:
  - `addPattern(type, pattern)` → increment frequency or insert new
  - `getPatterns(type, limit)` → retrieve most frequent patterns
  - `cacheDecision(context, question, answer)` → store with hash
  - `getCachedDecision(context, question)` → retrieve by hash
  - `recordExecution(planPath, duration, success, errors)` → log execution
  - `getExecutionHistory(limit)` → retrieve recent executions
  - `updateFile(path, summary, patterns)` → update file metadata
  - `getFile(path)` → retrieve file metadata
- Query helpers:
  - `findSimilarPatterns(pattern, threshold)` → fuzzy matching
  - `getSuccessRate(type)` → success metrics by pattern type
  - `getStats()` → overall memory statistics (counts, sizes)
- Connection management:
  - Singleton instance
  - Auto-create `.momentum/` directory
  - Graceful error handling

**Implementation Notes:**
```javascript
import Database from 'better-sqlite3';
import crypto from 'crypto';

class MemoryStore {
  constructor(dbPath = '.momentum/memory.db') {
    this.db = new Database(dbPath);
    this.initSchema();
  }

  hashContext(context, question) {
    return crypto.createHash('sha256')
      .update(JSON.stringify({ context, question }))
      .digest('hex');
  }
}
```

**Verification:**
- [ ] Database created at `.momentum/memory.db`
- [ ] All tables exist with correct schema
- [ ] CRUD operations work correctly
- [ ] Query helpers return expected results
- [ ] Stats show accurate counts

---

### Task 2: Create schema migration system
**File:** `momentum/lib/core/memory-schema.js`

**Requirements:**
- Version tracking table: `schema_version (version, applied_at)`
- Schema definitions as versioned migrations:
  - `v1`: Initial schema (4 tables)
  - Future: `v2`, `v3`, etc. for schema evolution
- Auto-migration on MemoryStore initialization:
  - Check current version
  - Apply missing migrations in order
  - Update version tracker
- Migration rollback support (optional for v1)
- Schema validation:
  - Verify table structure matches expected
  - Warn on missing indexes
  - Suggest reindex if needed

**Schema Definition:**
```sql
-- v1: Initial schema
CREATE TABLE IF NOT EXISTS patterns (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  type TEXT NOT NULL,
  pattern TEXT NOT NULL,
  frequency INTEGER DEFAULT 1,
  last_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(type, pattern)
);

CREATE TABLE IF NOT EXISTS decisions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  context_hash TEXT NOT NULL,
  question TEXT NOT NULL,
  answer TEXT NOT NULL,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_context_hash (context_hash)
);

CREATE TABLE IF NOT EXISTS executions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  plan_path TEXT NOT NULL,
  duration INTEGER,
  success INTEGER DEFAULT 1,
  errors TEXT,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS files (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  path TEXT UNIQUE NOT NULL,
  last_analyzed DATETIME DEFAULT CURRENT_TIMESTAMP,
  summary_hash TEXT,
  patterns TEXT
);

CREATE TABLE IF NOT EXISTS schema_version (
  version INTEGER PRIMARY KEY,
  applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**Verification:**
- [ ] Schema version tracked correctly
- [ ] Migrations apply in order
- [ ] Existing database upgrades without data loss
- [ ] Indexes created for performance

---

### Task 3: Add memory commands
**Files:**
- `momentum/commands/memory.js`
- Update `momentum/bin/cli.js` to register commands

**Commands:**

#### `momentum memory stats`
- Show memory usage statistics:
  - Total patterns by type
  - Total decisions cached
  - Total executions tracked
  - Database size
  - Success rate by pattern type
- Format as table with colors

**Output Example:**
```
Memory Statistics
─────────────────────────────────
Patterns:        142 (12 types)
Decisions:       89 cached
Executions:      45 tracked (91% success)
Database Size:   1.2 MB
Last Updated:    2 minutes ago
```

#### `momentum memory export [file]`
- Export memory to JSON file (default: `memory-export.json`)
- Include all tables
- Pretty-print JSON
- Confirm export path

**Output Format:**
```json
{
  "version": 1,
  "exported_at": "2024-12-18T10:30:00Z",
  "patterns": [...],
  "decisions": [...],
  "executions": [...],
  "files": [...]
}
```

#### `momentum memory import <file>`
- Import memory from JSON file
- Merge strategy:
  - Patterns: Merge frequencies
  - Decisions: Keep newer by timestamp
  - Executions: Append all
  - Files: Keep newer by last_analyzed
- Show summary of imported records
- Confirm before importing

#### `momentum memory clear`
- Clear all memory (with confirmation)
- Options:
  - `--patterns` - Clear only patterns
  - `--decisions` - Clear only decisions
  - `--executions` - Clear only executions
  - `--files` - Clear only files
- Require `--force` flag for full clear
- Show cleared counts

**Verification:**
- [ ] All commands work correctly
- [ ] Stats show accurate data
- [ ] Export/import preserves data
- [ ] Clear requires confirmation
- [ ] Help text is clear

---

## Dependencies

**NPM Package Required:**
```json
{
  "dependencies": {
    "better-sqlite3": "^9.2.2"
  }
}
```

Install: `npm install better-sqlite3`

**Existing Files to Modify:**
- `momentum/bin/cli.js` - Register memory commands
- `momentum/package.json` - Add better-sqlite3 dependency

---

## Success Criteria

- [ ] MemoryStore creates and manages SQLite database
- [ ] Schema migrations work automatically
- [ ] All CRUD operations function correctly
- [ ] Memory commands provide useful statistics
- [ ] Export/import preserves all data
- [ ] Queries execute in under 100ms
- [ ] Zero external services required (no Docker)

---

## Testing Strategy

1. **Unit Tests:**
   - Test CRUD operations
   - Test context hashing
   - Test pattern matching
   - Test query helpers

2. **Integration Tests:**
   - Test schema migration
   - Test export/import cycle
   - Test concurrent access
   - Test large datasets (1000+ records)

3. **Manual Testing:**
   - Run all memory commands
   - Verify stats accuracy
   - Test import/export workflow
   - Verify database file portability

---

## Notes

- SQLite is single-threaded, but sufficient for our use case
- Database file is portable across systems
- Future: Consider WAL mode for better concurrency
- Future: Add full-text search on patterns and decisions
- Future: Add embeddings table for semantic search (if needed)

---

**Estimated Time:** 3-4 hours
**Complexity:** Medium
**Priority:** High (Foundation for Phase 4)
